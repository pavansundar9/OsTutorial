<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Process Management</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=PT+Serif:ital@1&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Sofia&effect=neon|outline|emboss|shadow-multiple">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body>
    <div class="main">
        <div class="navbar">
            <div class="nav-container">
                <div class="icon">
                    <h2 class="font-effect-outline" style="color: coral;"><a href="index.html">MuRP</a></h2>
                </div>
                <div class="menu">
                    <ul>
                        <li><a href="index.html">HOME</a></li>
                        <li><a href="#">ABOUT</a></li>
                        <li><a href="#">SERVICE</a></li>
                        <li><a href="#">DESIGN</a></li>
                        <li><a href="#">CONTACT</a></li>
                    </ul>
                </div>
                <div class="search">
                    <input class="srch" type="search" name="" placeholder="Type to search">
                    <a href="#"><input type="button" value="Search"></a>
                </div>                
            </div>
        </div>
    </div>

    <div>
        <h2 class="sub-heading"><u>Process Secheduling</u>:</h2><br>
        <div class="gann">
            <!-- click the <a href="ganttchart.html">Table</a>to enter the values and generate ganttchart.
            <h4>Algorithems</h4> -->
            <p>
                The process scheduling is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy.<br>
                Process scheduling is an essential part of a Multiprogramming operating systems. Such operating systems allow more than one process to be loaded into the executable memory at a time and the loaded process shares the CPU using time multiplexing.
                The prime aim of the process scheduling system is to keep the CPU busy all the time and to deliver minimum response time for all programs. For achieving this, the scheduler must apply appropriate rules for swapping processes IN and OUT of CPU.
                <br><br>
                <h4 ><u>Scheduling fell into one of the two general categories</u>:</h4>
                <ou>
                    <li><b>Non Pre-emptive Scheduling:</b> When the currently executing process gives up the CPU voluntarily.</li>
                    <li><b>Pre-emptive Scheduling:</b> When the operating system decides to favour another process, pre-empting the currently executing process.</li>
                </ou>
                <br><br>
                <h4 >&nbsp;&nbsp;&nbsp;<u>Scheduling Queues:</u></h4>
                <p>
                    The OS maintains all PCBs in Process Scheduling Queues. 
                    The OS maintains a separate queue for each of the process states and PCBs of all processes in the same execution state are placed in the same queue. When the state of a process is changed, 
                    its PCB is unlinked from its current queue and moved to its new state queue.<br>
                    The Operating System maintains the following important process scheduling queues
                    <ou>
                    <li> <b>Job queue</b>-  This queue keeps all the processes in the system.</li>
                    <li><b>Ready queue</b> - This queue keeps a set of all processes residing in main memory, ready and waiting to execute. A new process is always put in this queue.</li>
                    <li><b>Device queues</b> - The processes which are blocked due to unavailability of an I/O device constitute this queue.</li>
                </ou><img src="schedule.PNG" >
                <p>
                A new process is initially put in the Ready queue. It waits in the ready queue until it is selected for execution(or dispatched). 
                Once the process is assigned to the CPU and is executing, one of the following several events can occur:
                <li>The process could issue an I/O request, and then be placed in the I/O queue.</li>
                <li>The process could create a new subprocess and wait for its termination.</li>
                <li>The process could be removed forcibly from the CPU, as a result of an interrupt, and be put back in the ready queue.</li>
                </p>
                <img src="schedule1.PNG" >
            </p>
            <div>
                <h2 class="hh4">Context Switch</h2>
                <p>
                    Context Switching involves storing the context or state of a process so that it can be reloaded when required and execution can be resumed from the same point as earlier. 
                    This is a feature of a multitasking operating system and allows a single CPU to be shared by multiple processes.<br>
                    <li>Switching the CPU to another process requires saving the state of the old process and loading the saved state for the new process. This task is known as a Context Switch.</li>
                    <li>The context of a process is represented in the Process Control Block(PCB) of a process; it includes the value of the CPU registers, the process state and memory-management information.
                         When a context switch occurs, the Kernel saves the context of the old process in its PCB and loads the saved context of the new process scheduled to run.</li>
                    <li>When a context switch occurs, the kernel saves the context of the old process in its PCB and loads the saved context of the new process scheduled to run.</li>
                    <li>Context-switch times are highly dependent on hardware support. For instance, some processors provide multiple sets of registers. A context switch here simply requires changing the pointer to the current register set. Of course,
                        if there are more active processes than there are register sets, the system resorts to copying register data to and from memory, as before.</li>
                </p><br>
                <p>
                    <pre><h4>     <i>WHY SWITCH PROCESSES</i></h4></pre><br>
                    <p>A context switching helps to share a single CPU across all processes to complete its execution and store the system's tasks status.
                    When the process reloads in the system, the execution of the process starts at the same point where there is conflicting.
                </p>
                    <ol>
                        <li>The switching of one process to another process is not directly in the system. A context switching helps the operating system that switches between the multiple processes to use the CPU's resource to accomplish its tasks and store its context. We can resume the service of the process at the same point later. 
                            If we do not store the currently running process's data or context, the stored data may be lost while switching between processes.</li>
                        <li>If a high priority process falls into the ready queue, the currently running process will be shut down or stopped by a high priority process to complete its tasks in the system.</li>
                        <li>If any running process requires I/O resources in the system, the current process will be switched by another process to use the CPUs. And when the I/O requirement is met, the old process goes into a ready state to wait for its execution in the CPU. Context switching stores the state of the process to resume its tasks in an operating system. 
                            Otherwise, the process needs to restart its execution from the initials level.</li>
                        <li>If any interrupts occur while running a process in the operating system, the process status is saved as registers using context switching. After resolving the interrupts, the process switches from a wait state to a ready state to resume its execution at the same point later, where the operating system interrupted occurs.</li>
                        <li>A context switching allows a single CPU to handle multiple process requests simultaneously without the need for any additional processors.</li>
                    </ol>
                </p><br>
                <p>
                    <pre><h4>       <i>WHEN TO SWITCH PROCESSES</i></h4></pre><br>
                    <p class="when">
                        A process switch may occur any time that the OS has gained control from the currently running process.
                        First, let us consider system interrupts. Actually, we can distinguish,as many systems do, two kinds of system interrupts, one of which is simply referred to as <b><i>an interrupt</i></b>, and the other as <b><i>a trap</i></b>. 
                        The former is due to some sort of event that is external to and independent of the currently running process, such as the completion of I/O operation.  
                        The latter relates to an error or exception condition generated within the currently running process, such as an illegal file access attempt. 
                        With an ordinary interrupt, control is first transferred to an interrupt handler, which does some basic housekeeping and then branches to an OS routine that is concerned with the particular type of interrupt that has occurred.
                        <li><b>Clock interrupt:</b> The OS determines whether the currently running process has been executing for the maximum allowable unit of time, referred to as a time slice. That is, a time slice is the maximum amount of time that a process can execute before being interrupted. 
                            If so, this process must be switched to a Ready state and another process dispatched</li>
                        <li><b>I/O interrupt: </b>The OS determines what I/O action has occurred. If the I/O action constitutes an event for which one or more processes are waiting, then the OS moves all of the corresponding blocked processes to the Ready state
                            (and Blocked/Suspend processes to the Ready/Suspend state). The OS must then decide whether to resume execution of the process currently in the Run
                            ning state, or to preempt that process for a higher-priority Ready process. </li>
                        <li><b>Memory fault: </b> The processor encounters a virtual memory address reference for a word that is not in main memory. The OS must bring in the block (page or segment) of memory containing the reference from secondary memory</li>
                    </p>
                </p>
                <br>
                <div class="Cprocess">
                    <p>
                    <pre class="Chead"><h4>    <u>   Steps involved in Context Switching   </u></h4></pre><br>
                    <p>
                    The process of context switching involves a number of steps. 
                    The following diagram depicts the process of context switching between the two processes P1 and P2.<br>
                    <br><br><img src="Cprocess.PNG" ><br><br>
                    In the above figure, you can see that initially, the process P1 is in the running state and the process P2 is in the ready state. Now, when some interruption occurs then you have to switch the process P1 from running to the ready state after saving the context and the process P2 from ready to running state. The following steps will be performed:
                <ol>
                    <li>Firstly, the context of the process P1 i.e. the process present in the running state will be saved in the Process Control Block of process P1 i.e. PCB1.</li>
                    <li>Now, you have to move the PCB1 to the relevant queue i.e. ready queue, I/O queue, waiting queue, etc.</li>
                    <li>From the ready state, select the new process that is to be executed i.e. the process P2.</li>
                    <li>Now, update the Process Control Block of process P2 i.e. PCB2 by setting the process state to running. If the process P2 was earlier executed by the CPU, then you can get the position of last executed instruction so that you can resume the execution of P2.</li>
                    <li>Similarly, if you want to execute the process P1 again, then you have to follow the same steps as mentioned above(from step 1 to 4).</li>
                </ol>
                    For context switching to happen, two processes are at least required in general, and in the case of the round-robin algorithm, you can perform context switching with the help of one process only.
                    The time involved in the context switching of one process by other is called the Context Switching Time.
                </p>
                    </p>
                </div>
            </div>
        </div>
        
    </div>
    <div class="NextPre">
        <button id="pre" class="pre" onclick="pre()"></a><i class="fa fa-angle-left" style="font-size:18px"></i>&nbsp;Previous</button>
        <button id="nxt" class="nxt" onclick="nxt()"></a>Next&nbsp;<i class="fa fa-angle-right" style="font-size:18px"></i></button>
    </div>
    <script type="text/javascript">
        document.getElementById("pre").onclick = function () {
        location.href = "process.html";
        };
        document.getElementById("nxt").onclick = function () {
        location.href = "algorithems.html";
        };
    </script>
</body>
</html>